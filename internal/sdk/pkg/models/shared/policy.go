// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package shared

import (
	"encoding/json"
	"fmt"
)

type PolicyAccountMaintenanceAccountsAccountAction string

const (
	PolicyAccountMaintenanceAccountsAccountActionCreate           PolicyAccountMaintenanceAccountsAccountAction = "Create"
	PolicyAccountMaintenanceAccountsAccountActionReset            PolicyAccountMaintenanceAccountsAccountAction = "Reset"
	PolicyAccountMaintenanceAccountsAccountActionDelete           PolicyAccountMaintenanceAccountsAccountAction = "Delete"
	PolicyAccountMaintenanceAccountsAccountActionDisableFileVault PolicyAccountMaintenanceAccountsAccountAction = "DisableFileVault"
)

func (e PolicyAccountMaintenanceAccountsAccountAction) ToPointer() *PolicyAccountMaintenanceAccountsAccountAction {
	return &e
}

func (e *PolicyAccountMaintenanceAccountsAccountAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Create":
		fallthrough
	case "Reset":
		fallthrough
	case "Delete":
		fallthrough
	case "DisableFileVault":
		*e = PolicyAccountMaintenanceAccountsAccountAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyAccountMaintenanceAccountsAccountAction: %v", v)
	}
}

type PolicyAccountMaintenanceAccountsAccount struct {
	Action                 *PolicyAccountMaintenanceAccountsAccountAction `json:"action,omitempty"`
	Admin                  *bool                                          `json:"admin,omitempty"`
	ArchiveHomeDirectory   *bool                                          `json:"archive_home_directory,omitempty"`
	ArchiveHomeDirectoryTo *string                                        `json:"archive_home_directory_to,omitempty"`
	FilevaultEnabled       *bool                                          `json:"filevault_enabled,omitempty"`
	Home                   *string                                        `json:"home,omitempty"`
	Password               *string                                        `json:"password,omitempty"`
	Picture                *string                                        `json:"picture,omitempty"`
	Realname               *string                                        `json:"realname,omitempty"`
	Username               *string                                        `json:"username,omitempty"`
}

type PolicyAccountMaintenanceAccounts struct {
	Account *PolicyAccountMaintenanceAccountsAccount `json:"account,omitempty"`
	Size    *int64                                   `json:"size,omitempty"`
}

type PolicyAccountMaintenanceDirectoryBindings struct {
	Binding *IDName `json:"binding,omitempty"`
	Size    *int64  `json:"size,omitempty"`
}

type PolicyAccountMaintenanceManagementAccountAction string

const (
	PolicyAccountMaintenanceManagementAccountActionSpecified        PolicyAccountMaintenanceManagementAccountAction = "specified"
	PolicyAccountMaintenanceManagementAccountActionRandom           PolicyAccountMaintenanceManagementAccountAction = "random"
	PolicyAccountMaintenanceManagementAccountActionReset            PolicyAccountMaintenanceManagementAccountAction = "reset"
	PolicyAccountMaintenanceManagementAccountActionFileVaultEnable  PolicyAccountMaintenanceManagementAccountAction = "fileVaultEnable"
	PolicyAccountMaintenanceManagementAccountActionFileVaultDisable PolicyAccountMaintenanceManagementAccountAction = "fileVaultDisable"
)

func (e PolicyAccountMaintenanceManagementAccountAction) ToPointer() *PolicyAccountMaintenanceManagementAccountAction {
	return &e
}

func (e *PolicyAccountMaintenanceManagementAccountAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "specified":
		fallthrough
	case "random":
		fallthrough
	case "reset":
		fallthrough
	case "fileVaultEnable":
		fallthrough
	case "fileVaultDisable":
		*e = PolicyAccountMaintenanceManagementAccountAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyAccountMaintenanceManagementAccountAction: %v", v)
	}
}

type PolicyAccountMaintenanceManagementAccount struct {
	Action          *PolicyAccountMaintenanceManagementAccountAction `json:"action,omitempty"`
	ManagedPassword *string                                          `json:"managed_password,omitempty"`
	// Only necessary when utilizing the random action
	ManagedPasswordLength *int64 `json:"managed_password_length,omitempty"`
}

type PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode string

const (
	PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfModeCommand PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode = "command"
	PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfModeNone    PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode = "none"
)

func (e PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode) ToPointer() *PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode {
	return &e
}

func (e *PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "command":
		fallthrough
	case "none":
		*e = PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode: %v", v)
	}
}

type PolicyAccountMaintenanceOpenFirmwareEfiPassword struct {
	OfMode     *PolicyAccountMaintenanceOpenFirmwareEfiPasswordOfMode `json:"of_mode,omitempty"`
	OfPassword *string                                                `json:"of_password,omitempty"`
}

type PolicyAccountMaintenance struct {
	Accounts                []PolicyAccountMaintenanceAccounts               `json:"accounts,omitempty"`
	DirectoryBindings       []PolicyAccountMaintenanceDirectoryBindings      `json:"directory_bindings,omitempty"`
	ManagementAccount       *PolicyAccountMaintenanceManagementAccount       `json:"management_account,omitempty"`
	OpenFirmwareEfiPassword *PolicyAccountMaintenanceOpenFirmwareEfiPassword `json:"open_firmware_efi_password,omitempty"`
}

type PolicyDiskEncryptionAction string

const (
	PolicyDiskEncryptionActionApply     PolicyDiskEncryptionAction = "apply"
	PolicyDiskEncryptionActionRemediate PolicyDiskEncryptionAction = "remediate"
)

func (e PolicyDiskEncryptionAction) ToPointer() *PolicyDiskEncryptionAction {
	return &e
}

func (e *PolicyDiskEncryptionAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "apply":
		fallthrough
	case "remediate":
		*e = PolicyDiskEncryptionAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyDiskEncryptionAction: %v", v)
	}
}

type PolicyDiskEncryptionRemediateKeyType string

const (
	PolicyDiskEncryptionRemediateKeyTypeIndividual                 PolicyDiskEncryptionRemediateKeyType = "Individual"
	PolicyDiskEncryptionRemediateKeyTypeInstitutional              PolicyDiskEncryptionRemediateKeyType = "Institutional"
	PolicyDiskEncryptionRemediateKeyTypeIndividualAndInstitutional PolicyDiskEncryptionRemediateKeyType = "Individual And Institutional"
)

func (e PolicyDiskEncryptionRemediateKeyType) ToPointer() *PolicyDiskEncryptionRemediateKeyType {
	return &e
}

func (e *PolicyDiskEncryptionRemediateKeyType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Individual":
		fallthrough
	case "Institutional":
		fallthrough
	case "Individual And Institutional":
		*e = PolicyDiskEncryptionRemediateKeyType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyDiskEncryptionRemediateKeyType: %v", v)
	}
}

type PolicyDiskEncryption struct {
	Action                        *PolicyDiskEncryptionAction `json:"action,omitempty"`
	AuthRestart                   *bool                       `json:"auth_restart,omitempty"`
	DiskEncryptionConfigurationID *int64                      `json:"disk_encryption_configuration_id,omitempty"`
	// disk encryption ID to utilize for remediating institutional recovery key types.
	RemediateDiskEncryptionConfigurationID *int64                                `json:"remediate_disk_encryption_configuration_id,omitempty"`
	RemediateKeyType                       *PolicyDiskEncryptionRemediateKeyType `json:"remediate_key_type,omitempty"`
}

type PolicyDockItemsDockItemAction string

const (
	PolicyDockItemsDockItemActionAddToBeginning PolicyDockItemsDockItemAction = "Add To Beginning"
	PolicyDockItemsDockItemActionAddToEnd       PolicyDockItemsDockItemAction = "Add To End"
	PolicyDockItemsDockItemActionRemove         PolicyDockItemsDockItemAction = "Remove"
)

func (e PolicyDockItemsDockItemAction) ToPointer() *PolicyDockItemsDockItemAction {
	return &e
}

func (e *PolicyDockItemsDockItemAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Add To Beginning":
		fallthrough
	case "Add To End":
		fallthrough
	case "Remove":
		*e = PolicyDockItemsDockItemAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyDockItemsDockItemAction: %v", v)
	}
}

type PolicyDockItemsDockItem struct {
	Action *PolicyDockItemsDockItemAction `json:"action,omitempty"`
	ID     *int64                         `json:"id,omitempty"`
	Name   *string                        `json:"name,omitempty"`
}

type PolicyDockItems struct {
	DockItem *PolicyDockItemsDockItem `json:"dock_item,omitempty"`
	Size     *int64                   `json:"size,omitempty"`
}

type PolicyFilesProcesses struct {
	DeleteFile           *bool   `json:"delete_file,omitempty"`
	KillProcess          *bool   `json:"kill_process,omitempty"`
	LocateFile           *string `json:"locate_file,omitempty"`
	RunCommand           *string `json:"run_command,omitempty"`
	SearchByPath         *string `json:"search_by_path,omitempty"`
	SearchForProcess     *string `json:"search_for_process,omitempty"`
	SpotlightSearch      *string `json:"spotlight_search,omitempty"`
	UpdateLocateDatabase *bool   `json:"update_locate_database,omitempty"`
}

type PolicyGeneralDateTimeLimitationsNoExecuteOnDay string

const (
	PolicyGeneralDateTimeLimitationsNoExecuteOnDaySun PolicyGeneralDateTimeLimitationsNoExecuteOnDay = "Sun"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayMon PolicyGeneralDateTimeLimitationsNoExecuteOnDay = "Mon"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayTue PolicyGeneralDateTimeLimitationsNoExecuteOnDay = "Tue"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayWed PolicyGeneralDateTimeLimitationsNoExecuteOnDay = "Wed"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayThu PolicyGeneralDateTimeLimitationsNoExecuteOnDay = "Thu"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDayFri PolicyGeneralDateTimeLimitationsNoExecuteOnDay = "Fri"
	PolicyGeneralDateTimeLimitationsNoExecuteOnDaySat PolicyGeneralDateTimeLimitationsNoExecuteOnDay = "Sat"
)

func (e PolicyGeneralDateTimeLimitationsNoExecuteOnDay) ToPointer() *PolicyGeneralDateTimeLimitationsNoExecuteOnDay {
	return &e
}

func (e *PolicyGeneralDateTimeLimitationsNoExecuteOnDay) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Sun":
		fallthrough
	case "Mon":
		fallthrough
	case "Tue":
		fallthrough
	case "Wed":
		fallthrough
	case "Thu":
		fallthrough
	case "Fri":
		fallthrough
	case "Sat":
		*e = PolicyGeneralDateTimeLimitationsNoExecuteOnDay(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyGeneralDateTimeLimitationsNoExecuteOnDay: %v", v)
	}
}

type PolicyGeneralDateTimeLimitationsNoExecuteOn struct {
	Day *PolicyGeneralDateTimeLimitationsNoExecuteOnDay `json:"day,omitempty"`
}

type PolicyGeneralDateTimeLimitations struct {
	ActivationDate      *string                                      `json:"activation_date,omitempty"`
	ActivationDateEpoch *int64                                       `json:"activation_date_epoch,omitempty"`
	ActivationDateUtc   *string                                      `json:"activation_date_utc,omitempty"`
	ExpirationDate      *string                                      `json:"expiration_date,omitempty"`
	ExpirationDateEpoch *int64                                       `json:"expiration_date_epoch,omitempty"`
	ExpirationDateUtc   *string                                      `json:"expiration_date_utc,omitempty"`
	NoExecuteEnd        *string                                      `json:"no_execute_end,omitempty"`
	NoExecuteOn         *PolicyGeneralDateTimeLimitationsNoExecuteOn `json:"no_execute_on,omitempty"`
	NoExecuteStart      *string                                      `json:"no_execute_start,omitempty"`
}

type PolicyGeneralFrequency string

const (
	PolicyGeneralFrequencyOncePerComputer        PolicyGeneralFrequency = "Once per computer"
	PolicyGeneralFrequencyOncePerUserPerComputer PolicyGeneralFrequency = "Once per user per computer"
	PolicyGeneralFrequencyOncePerUser            PolicyGeneralFrequency = "Once per user"
	PolicyGeneralFrequencyOnceEveryDay           PolicyGeneralFrequency = "Once every day"
	PolicyGeneralFrequencyOnceEveryWeek          PolicyGeneralFrequency = "Once every week"
	PolicyGeneralFrequencyOnceEveryMonth         PolicyGeneralFrequency = "Once every month"
	PolicyGeneralFrequencyOngoing                PolicyGeneralFrequency = "Ongoing"
)

func (e PolicyGeneralFrequency) ToPointer() *PolicyGeneralFrequency {
	return &e
}

func (e *PolicyGeneralFrequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Once per computer":
		fallthrough
	case "Once per user per computer":
		fallthrough
	case "Once per user":
		fallthrough
	case "Once every day":
		fallthrough
	case "Once every week":
		fallthrough
	case "Once every month":
		fallthrough
	case "Ongoing":
		*e = PolicyGeneralFrequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyGeneralFrequency: %v", v)
	}
}

type PolicyGeneralNetworkLimitationsMinimumNetworkConnection string

const (
	PolicyGeneralNetworkLimitationsMinimumNetworkConnectionNoMinimum PolicyGeneralNetworkLimitationsMinimumNetworkConnection = "No Minimum"
	PolicyGeneralNetworkLimitationsMinimumNetworkConnectionEthernet  PolicyGeneralNetworkLimitationsMinimumNetworkConnection = "Ethernet"
)

func (e PolicyGeneralNetworkLimitationsMinimumNetworkConnection) ToPointer() *PolicyGeneralNetworkLimitationsMinimumNetworkConnection {
	return &e
}

func (e *PolicyGeneralNetworkLimitationsMinimumNetworkConnection) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "No Minimum":
		fallthrough
	case "Ethernet":
		*e = PolicyGeneralNetworkLimitationsMinimumNetworkConnection(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyGeneralNetworkLimitationsMinimumNetworkConnection: %v", v)
	}
}

type PolicyGeneralNetworkLimitations struct {
	AnyIPAddress             *bool                                                    `json:"any_ip_address,omitempty"`
	MinimumNetworkConnection *PolicyGeneralNetworkLimitationsMinimumNetworkConnection `json:"minimum_network_connection,omitempty"`
}

type PolicyGeneralNetworkRequirements string

const (
	PolicyGeneralNetworkRequirementsAny      PolicyGeneralNetworkRequirements = "Any"
	PolicyGeneralNetworkRequirementsEthernet PolicyGeneralNetworkRequirements = "Ethernet"
)

func (e PolicyGeneralNetworkRequirements) ToPointer() *PolicyGeneralNetworkRequirements {
	return &e
}

func (e *PolicyGeneralNetworkRequirements) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Any":
		fallthrough
	case "Ethernet":
		*e = PolicyGeneralNetworkRequirements(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyGeneralNetworkRequirements: %v", v)
	}
}

type PolicyGeneralOverrideDefaultSettings struct {
	DistributionPoint *string `json:"distribution_point,omitempty"`
	ForceAfpSmb       *bool   `json:"force_afp_smb,omitempty"`
	Sus               *string `json:"sus,omitempty"`
	TargetDrive       *string `json:"target_drive,omitempty"`
}

type PolicyGeneralRetryEvent string

const (
	PolicyGeneralRetryEventNone    PolicyGeneralRetryEvent = "none"
	PolicyGeneralRetryEventTrigger PolicyGeneralRetryEvent = "trigger"
	PolicyGeneralRetryEventCheckIn PolicyGeneralRetryEvent = "check-in"
)

func (e PolicyGeneralRetryEvent) ToPointer() *PolicyGeneralRetryEvent {
	return &e
}

func (e *PolicyGeneralRetryEvent) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "trigger":
		fallthrough
	case "check-in":
		*e = PolicyGeneralRetryEvent(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyGeneralRetryEvent: %v", v)
	}
}

type PolicyGeneral struct {
	Category                   *CategoryObject                       `json:"category,omitempty"`
	DateTimeLimitations        *PolicyGeneralDateTimeLimitations     `json:"date_time_limitations,omitempty"`
	Enabled                    *bool                                 `json:"enabled,omitempty"`
	Frequency                  *PolicyGeneralFrequency               `json:"frequency,omitempty"`
	ID                         *int64                                `json:"id,omitempty"`
	LocationUserOnly           *bool                                 `json:"location_user_only,omitempty"`
	Name                       string                                `json:"name"`
	NetworkLimitations         *PolicyGeneralNetworkLimitations      `json:"network_limitations,omitempty"`
	NetworkRequirements        *PolicyGeneralNetworkRequirements     `json:"network_requirements,omitempty"`
	NotifyOnEachFailedRetry    *bool                                 `json:"notify_on_each_failed_retry,omitempty"`
	Offline                    *bool                                 `json:"offline,omitempty"`
	OverrideDefaultSettings    *PolicyGeneralOverrideDefaultSettings `json:"override_default_settings,omitempty"`
	RetryAttempts              *int64                                `json:"retry_attempts,omitempty"`
	RetryEvent                 *PolicyGeneralRetryEvent              `json:"retry_event,omitempty"`
	Site                       *SiteObject                           `json:"site,omitempty"`
	TargetDrive                *string                               `json:"target_drive,omitempty"`
	Trigger                    *string                               `json:"trigger,omitempty"`
	TriggerCheckin             *bool                                 `json:"trigger_checkin,omitempty"`
	TriggerEnrollmentComplete  *bool                                 `json:"trigger_enrollment_complete,omitempty"`
	TriggerLogin               *bool                                 `json:"trigger_login,omitempty"`
	TriggerLogout              *bool                                 `json:"trigger_logout,omitempty"`
	TriggerNetworkStateChanged *bool                                 `json:"trigger_network_state_changed,omitempty"`
	TriggerOther               *string                               `json:"trigger_other,omitempty"`
	TriggerStartup             *bool                                 `json:"trigger_startup,omitempty"`
}

type PolicyMaintenance struct {
	Byhost                   *bool `json:"byhost,omitempty"`
	Heal                     *bool `json:"heal,omitempty"`
	InstallAllCachedPackages *bool `json:"install_all_cached_packages,omitempty"`
	Permissions              *bool `json:"permissions,omitempty"`
	Prebindings              *bool `json:"prebindings,omitempty"`
	Recon                    *bool `json:"recon,omitempty"`
	ResetName                *bool `json:"reset_name,omitempty"`
	SystemCache              *bool `json:"system_cache,omitempty"`
	UserCache                *bool `json:"user_cache,omitempty"`
	Verify                   *bool `json:"verify,omitempty"`
}

type PolicyPackageConfigurationPackagesPackageAction string

const (
	PolicyPackageConfigurationPackagesPackageActionInstall       PolicyPackageConfigurationPackagesPackageAction = "Install"
	PolicyPackageConfigurationPackagesPackageActionCache         PolicyPackageConfigurationPackagesPackageAction = "Cache"
	PolicyPackageConfigurationPackagesPackageActionInstallCached PolicyPackageConfigurationPackagesPackageAction = "Install Cached"
)

func (e PolicyPackageConfigurationPackagesPackageAction) ToPointer() *PolicyPackageConfigurationPackagesPackageAction {
	return &e
}

func (e *PolicyPackageConfigurationPackagesPackageAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Install":
		fallthrough
	case "Cache":
		fallthrough
	case "Install Cached":
		*e = PolicyPackageConfigurationPackagesPackageAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyPackageConfigurationPackagesPackageAction: %v", v)
	}
}

type PolicyPackageConfigurationPackagesPackage struct {
	Action        *PolicyPackageConfigurationPackagesPackageAction `json:"action,omitempty"`
	Feu           *bool                                            `json:"feu,omitempty"`
	Fut           *bool                                            `json:"fut,omitempty"`
	ID            *int64                                           `json:"id,omitempty"`
	Name          *string                                          `json:"name,omitempty"`
	UpdateAutorun *bool                                            `json:"update_autorun,omitempty"`
}

type PolicyPackageConfigurationPackages struct {
	Package *PolicyPackageConfigurationPackagesPackage `json:"package,omitempty"`
	Size    *int64                                     `json:"size,omitempty"`
}

type PolicyPackageConfiguration struct {
	Packages []PolicyPackageConfigurationPackages `json:"packages,omitempty"`
}

type PolicyPrintersPrinterAction string

const (
	PolicyPrintersPrinterActionInstall   PolicyPrintersPrinterAction = "install"
	PolicyPrintersPrinterActionUninstall PolicyPrintersPrinterAction = "uninstall"
)

func (e PolicyPrintersPrinterAction) ToPointer() *PolicyPrintersPrinterAction {
	return &e
}

func (e *PolicyPrintersPrinterAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "install":
		fallthrough
	case "uninstall":
		*e = PolicyPrintersPrinterAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyPrintersPrinterAction: %v", v)
	}
}

type PolicyPrintersPrinter struct {
	Action      *PolicyPrintersPrinterAction `json:"action,omitempty"`
	ID          *int64                       `json:"id,omitempty"`
	MakeDefault *bool                        `json:"make_default,omitempty"`
	Name        *string                      `json:"name,omitempty"`
}

type PolicyPrinters struct {
	LeaveExistingDefault *string                `json:"leave_existing_default,omitempty"`
	Printer              *PolicyPrintersPrinter `json:"printer,omitempty"`
	Size                 *int64                 `json:"size,omitempty"`
}

type PolicyScopeBuildings struct {
	Building *IDName `json:"building,omitempty"`
}

type PolicyScopeComputerGroups struct {
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

type PolicyScopeComputersComputer struct {
	ID *int64 `json:"id,omitempty"`
	// Name of the computer
	Name *string `json:"name,omitempty"`
	Udid *string `json:"udid,omitempty"`
}

type PolicyScopeComputers struct {
	Computer *PolicyScopeComputersComputer `json:"computer,omitempty"`
}

type PolicyScopeDepartments struct {
	Department *IDName `json:"department,omitempty"`
}

type PolicyScopeExclusionsBuildings struct {
	Building *IDName `json:"building,omitempty"`
}

type PolicyScopeExclusionsComputerGroups struct {
	ComputerGroup *IDName `json:"computer_group,omitempty"`
}

type PolicyScopeExclusionsComputersComputer struct {
	ID *int64 `json:"id,omitempty"`
	// Name of the computer
	Name *string `json:"name,omitempty"`
	Udid *string `json:"udid,omitempty"`
}

type PolicyScopeExclusionsComputers struct {
	Computer *PolicyScopeExclusionsComputersComputer `json:"computer,omitempty"`
}

type PolicyScopeExclusionsDepartments struct {
	Department *IDName `json:"department,omitempty"`
}

type PolicyScopeExclusionsIbeacons struct {
	Ibeacon *IDName `json:"ibeacon,omitempty"`
}

type PolicyScopeExclusionsNetworkSegmentsNetworkSegment struct {
	ID *int64 `json:"id,omitempty"`
	// Name of the network segment
	Name *string `json:"name,omitempty"`
	UID  *string `json:"uid,omitempty"`
}

type PolicyScopeExclusionsNetworkSegments struct {
	NetworkSegment *PolicyScopeExclusionsNetworkSegmentsNetworkSegment `json:"network_segment,omitempty"`
}

type PolicyScopeExclusionsUserGroups struct {
	UserGroup *IDName `json:"user_group,omitempty"`
}

type PolicyScopeExclusionsUsersUser struct {
	Name *string `json:"name,omitempty"`
}

type PolicyScopeExclusionsUsers struct {
	User *PolicyScopeExclusionsUsersUser `json:"user,omitempty"`
}

type PolicyScopeExclusions struct {
	Buildings       []PolicyScopeExclusionsBuildings       `json:"buildings,omitempty"`
	ComputerGroups  []PolicyScopeExclusionsComputerGroups  `json:"computer_groups,omitempty"`
	Computers       []PolicyScopeExclusionsComputers       `json:"computers,omitempty"`
	Departments     []PolicyScopeExclusionsDepartments     `json:"departments,omitempty"`
	Ibeacons        []PolicyScopeExclusionsIbeacons        `json:"ibeacons,omitempty"`
	NetworkSegments []PolicyScopeExclusionsNetworkSegments `json:"network_segments,omitempty"`
	UserGroups      []PolicyScopeExclusionsUserGroups      `json:"user_groups,omitempty"`
	Users           []PolicyScopeExclusionsUsers           `json:"users,omitempty"`
}

type PolicyScopeLimitToUsersUserGroups struct {
	UserGroup *string `json:"user_group,omitempty"`
}

type PolicyScopeLimitToUsers struct {
	UserGroups []PolicyScopeLimitToUsersUserGroups `json:"user_groups,omitempty"`
}

type PolicyScopeLimitationsIbeacons struct {
	Ibeacon *IDName `json:"ibeacon,omitempty"`
}

type PolicyScopeLimitationsNetworkSegments struct {
	NetworkSegment *IDName `json:"network_segment,omitempty"`
}

type PolicyScopeLimitationsUserGroups struct {
	UserGroup *IDName `json:"user_group,omitempty"`
}

type PolicyScopeLimitationsUsers struct {
	User *IDName `json:"user,omitempty"`
}

type PolicyScopeLimitations struct {
	Ibeacons        []PolicyScopeLimitationsIbeacons        `json:"ibeacons,omitempty"`
	NetworkSegments []PolicyScopeLimitationsNetworkSegments `json:"network_segments,omitempty"`
	UserGroups      []PolicyScopeLimitationsUserGroups      `json:"user_groups,omitempty"`
	Users           []PolicyScopeLimitationsUsers           `json:"users,omitempty"`
}

type PolicyScope struct {
	AllComputers   *bool                       `json:"all_computers,omitempty"`
	Buildings      []PolicyScopeBuildings      `json:"buildings,omitempty"`
	ComputerGroups []PolicyScopeComputerGroups `json:"computer_groups,omitempty"`
	Computers      []PolicyScopeComputers      `json:"computers,omitempty"`
	Departments    []PolicyScopeDepartments    `json:"departments,omitempty"`
	Exclusions     *PolicyScopeExclusions      `json:"exclusions,omitempty"`
	LimitToUsers   *PolicyScopeLimitToUsers    `json:"limit_to_users,omitempty"`
	Limitations    *PolicyScopeLimitations     `json:"limitations,omitempty"`
}

type PolicyScriptsScriptPriority string

const (
	PolicyScriptsScriptPriorityBefore PolicyScriptsScriptPriority = "Before"
	PolicyScriptsScriptPriorityAfter  PolicyScriptsScriptPriority = "After"
)

func (e PolicyScriptsScriptPriority) ToPointer() *PolicyScriptsScriptPriority {
	return &e
}

func (e *PolicyScriptsScriptPriority) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "Before":
		fallthrough
	case "After":
		*e = PolicyScriptsScriptPriority(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PolicyScriptsScriptPriority: %v", v)
	}
}

type PolicyScriptsScript struct {
	ID          *int64                       `json:"id,omitempty"`
	Name        *string                      `json:"name,omitempty"`
	Parameter10 *string                      `json:"parameter10,omitempty"`
	Parameter11 *string                      `json:"parameter11,omitempty"`
	Parameter4  *string                      `json:"parameter4,omitempty"`
	Parameter5  *string                      `json:"parameter5,omitempty"`
	Parameter6  *string                      `json:"parameter6,omitempty"`
	Parameter7  *string                      `json:"parameter7,omitempty"`
	Parameter8  *string                      `json:"parameter8,omitempty"`
	Parameter9  *string                      `json:"parameter9,omitempty"`
	Priority    *PolicyScriptsScriptPriority `json:"priority,omitempty"`
}

type PolicyScripts struct {
	Script []PolicyScriptsScript `json:"script,omitempty"`
	Size   *int64                `json:"size,omitempty"`
}

type PolicySelfServiceSelfServiceCategoriesCategory struct {
	DisplayIn *bool   `json:"display_in,omitempty"`
	FeatureIn *bool   `json:"feature_in,omitempty"`
	ID        *int64  `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
}

type PolicySelfServiceSelfServiceCategories struct {
	Category *PolicySelfServiceSelfServiceCategoriesCategory `json:"category,omitempty"`
}

type PolicySelfServiceSelfServiceIcon struct {
	Filename *string `json:"filename,omitempty"`
	ID       *int64  `json:"id,omitempty"`
	URI      *string `json:"uri,omitempty"`
}

type PolicySelfService struct {
	FeatureOnMainPage           *bool                                   `json:"feature_on_main_page,omitempty"`
	ForceUsersToViewDescription *bool                                   `json:"force_users_to_view_description,omitempty"`
	InstallButtonText           *string                                 `json:"install_button_text,omitempty"`
	ReInstallButtonText         *string                                 `json:"re-install_button_text,omitempty"`
	SelfServiceCategories       *PolicySelfServiceSelfServiceCategories `json:"self_service_categories,omitempty"`
	SelfServiceDescription      *string                                 `json:"self_service_description,omitempty"`
	SelfServiceDisplayName      *string                                 `json:"self_service_display_name,omitempty"`
	SelfServiceIcon             *PolicySelfServiceSelfServiceIcon       `json:"self_service_icon,omitempty"`
	UseForSelfService           *bool                                   `json:"use_for_self_service,omitempty"`
}

type PolicyUserInteraction struct {
	AllowDeferralMinutes  *int64  `json:"allow_deferral_minutes,omitempty"`
	AllowDeferralUntilUtc *string `json:"allow_deferral_until_utc,omitempty"`
	AllowUserToDefer      *bool   `json:"allow_user_to_defer,omitempty"`
	MessageFinish         *string `json:"message_finish,omitempty"`
	MessageStart          *string `json:"message_start,omitempty"`
}

// Policy - OK
type Policy struct {
	AccountMaintenance   *PolicyAccountMaintenance   `json:"account_maintenance,omitempty"`
	DiskEncryption       *PolicyDiskEncryption       `json:"disk_encryption,omitempty"`
	DockItems            []PolicyDockItems           `json:"dock_items,omitempty"`
	FilesProcesses       *PolicyFilesProcesses       `json:"files_processes,omitempty"`
	General              *PolicyGeneral              `json:"general,omitempty"`
	Maintenance          *PolicyMaintenance          `json:"maintenance,omitempty"`
	PackageConfiguration *PolicyPackageConfiguration `json:"package_configuration,omitempty"`
	Printers             []PolicyPrinters            `json:"printers,omitempty"`
	Scope                *PolicyScope                `json:"scope,omitempty"`
	Scripts              *PolicyScripts              `json:"scripts,omitempty"`
	SelfService          *PolicySelfService          `json:"self_service,omitempty"`
	UserInteraction      *PolicyUserInteraction      `json:"user_interaction,omitempty"`
}
